<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C++耗时统计</title>
      <link href="/posts/a4ad/"/>
      <url>/posts/a4ad/</url>
      
        <content type="html"><![CDATA[<p>从 C++ 11 开始，计算程序耗时的最佳方法是使用标准库<code>&lt;chrono&gt;</code>。</p><p>以下 C++ 程序，分别以秒、毫秒、微秒、纳秒为单位，计算程序的耗时：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> start = std::chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要统计耗时的代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line">    <span class="built_in">Sleep</span>(<span class="number">1000</span>); <span class="comment">// Windows 平台，以毫秒为单位</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1</span>); <span class="comment">// Linux 平台，以秒为单位</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> end = std::chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Elapsed time in seconds: &quot;</span></span><br><span class="line">        &lt;&lt; std::chrono::<span class="built_in">duration_cast</span>&lt;std::chrono::seconds&gt;(end - start).<span class="built_in">count</span>()</span><br><span class="line">        &lt;&lt; <span class="string">&quot; sec&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Elapsed time in milliseconds: &quot;</span></span><br><span class="line">        &lt;&lt; std::chrono::<span class="built_in">duration_cast</span>&lt;std::chrono::milliseconds&gt;(end - start).<span class="built_in">count</span>()</span><br><span class="line">        &lt;&lt; <span class="string">&quot; ms&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Elapsed time in microseconds: &quot;</span></span><br><span class="line">        &lt;&lt; std::chrono::<span class="built_in">duration_cast</span>&lt;std::chrono::microseconds&gt;(end - start).<span class="built_in">count</span>()</span><br><span class="line">        &lt;&lt; <span class="string">&quot; us&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Elapsed time in nanoseconds: &quot;</span></span><br><span class="line">        &lt;&lt; std::chrono::<span class="built_in">duration_cast</span>&lt;std::chrono::nanoseconds&gt;(end - start).<span class="built_in">count</span>()</span><br><span class="line">        &lt;&lt; <span class="string">&quot; ns&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本文转自 <a href="https://www.techiedelight.com/measure-elapsed-time-program-chrono-library/">techiedelight</a> ，本来打算自己写一个，但从网上搜到了这篇博客，感觉写的挺好，就直接转过来了。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码积累 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++遍历文件夹下所有文件</title>
      <link href="/posts/2370/"/>
      <url>/posts/2370/</url>
      
        <content type="html"><![CDATA[<p>在日常的工作学习中，偶尔会需要写一些小工具，小 demo，经常会需要遍历文件夹下所有的文件。每当这个时候，总是需要去网上搜一下遍历文件夹的函数，然后自己再根据需求做一些修改。</p><p>数次有过想法，想要自己整理出一个好用的遍历文件夹的函数，一直因为懒惰没有实现。正好前两天又遇到了这个问题，再加上当天有一些空闲时间，于是就查阅资料，自己写了一个遍历函数出来。</p><p>该函数的优点：</p><ol><li>使用 C++ 标准库实现，支持 Windows 和 Linux 平台。</li><li>可根据输入参数，选择是否递归遍历文件夹的子文件夹。</li><li>可根据输入参数，选择是否对文件扩展名进行筛选。</li></ol><p>该函数的缺陷：</p><ol><li>调用了 C++ 17 的标准库 <code>&lt;filesystem&gt;</code>，因此编程环境需要支持 C++ 17。</li></ol><p>函数的源代码如下，具体使用方法见代码注释。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;filesystem&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 遍历文件夹下所有文件</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @author 孙鹏宇</span></span><br><span class="line"><span class="comment"> * @date 2023年3月15日</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param[in]   directory_path  要遍历的文件夹路径，末尾可加&quot;/&quot;，也可以不加</span></span><br><span class="line"><span class="comment"> * @param[out]  files_path      所有文件路径的vector&lt;string&gt;，若传入不为空，则不会将其清空，而是在末尾增加。</span></span><br><span class="line"><span class="comment"> * @param[in]   is_recursive    是否递归遍历子文件夹，默认为false。</span></span><br><span class="line"><span class="comment"> * @param[in]   extension       根据文件扩展名筛选，默认不筛选。若要筛选，需要传入小数点+扩展名，例如&quot;.bmp&quot;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return 遍历成功返回true，否则返回false</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @note</span></span><br><span class="line"><span class="comment"> *  1、调用了C++ 17中的filesystem，因此编译器必须支持C++ 17</span></span><br><span class="line"><span class="comment"> *  2、如果directory_path传入的是一个具体文件名，则会自动提取所在文件夹</span></span><br><span class="line"><span class="comment"> *  3、如果不需要递归遍历子文件夹和筛选文件扩展名，后两个参数可以省略。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">traverse_files</span><span class="params">(std::string directory_path, std::vector&lt;std::string&gt;&amp; files_path, <span class="type">bool</span> is_recursive = <span class="literal">false</span>, <span class="type">const</span> std::string&amp; extension = <span class="string">&quot;&quot;</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!std::filesystem::<span class="built_in">exists</span>(directory_path))</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;目录 &quot;</span> &lt;&lt; directory_path &lt;&lt; <span class="string">&quot; 不存在！&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!std::filesystem::<span class="built_in">is_directory</span>(directory_path))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (std::filesystem::<span class="built_in">is_regular_file</span>(directory_path))</span><br><span class="line">        &#123;</span><br><span class="line">            std::filesystem::path file_path = directory_path;</span><br><span class="line">            directory_path = file_path.<span class="built_in">parent_path</span>().<span class="built_in">string</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (is_recursive)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; entry : std::filesystem::<span class="built_in">recursive_directory_iterator</span>(directory_path))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry.<span class="built_in">is_regular_file</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (extension != <span class="string">&quot;&quot;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (entry.<span class="built_in">path</span>().<span class="built_in">extension</span>().<span class="built_in">string</span>() == extension)</span><br><span class="line">                    &#123;</span><br><span class="line">                        files_path.<span class="built_in">push_back</span>(entry.<span class="built_in">path</span>().<span class="built_in">string</span>());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    files_path.<span class="built_in">push_back</span>(entry.<span class="built_in">path</span>().<span class="built_in">string</span>());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; entry : std::filesystem::<span class="built_in">directory_iterator</span>(directory_path))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry.<span class="built_in">is_regular_file</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (extension != <span class="string">&quot;&quot;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (entry.<span class="built_in">path</span>().<span class="built_in">extension</span>().<span class="built_in">string</span>() == extension)</span><br><span class="line">                    &#123;</span><br><span class="line">                        files_path.<span class="built_in">push_back</span>(entry.<span class="built_in">path</span>().<span class="built_in">string</span>());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    files_path.<span class="built_in">push_back</span>(entry.<span class="built_in">path</span>().<span class="built_in">string</span>());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>感觉 C++ 17 的标准库 <code>&lt;filesystem&gt;</code> 还是挺好用的，有时间要好好整理一下，这里先留个坑。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码积累 </tag>
            
            <tag> todo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SIMD入门系列(001)-简介</title>
      <link href="/posts/1fcc/"/>
      <url>/posts/1fcc/</url>
      
        <content type="html"><![CDATA[<h1>SIMD简介</h1><p>SIMD，即 Single Instruction, Multiple Data（单指令多数据），一条指令操作多个数据，是一种并行计算技术，CPU 可以使用 SIMD 技术对多个数据项<strong>同时执行</strong>某个操作。</p><p>SIMD 是一种并行架构类型，本质上是采用一个控制器来控制多个处理器，同时对一组数据中的每一个分别执行相同的操作，从而实现空间上的并行性的技术。</p><p>SIMD 经常被用于机器学习、图像处理、音视频编码和解码、数据挖掘和计算机图形学等领域，加速这些领域中计算密集型的算法和函数的性能。</p><p>比如在图像处理领域，图像的一个像素往往用 8位数据表示，但 CPU 的寄存器往往是32位或 64位，处理这些像素只能用到寄存器的低 8位，这就造成了资源的浪费。如果把一个 64位寄存器拆成 8 个 8位寄存器，就能同时对 8个像素进行操作，计算效率提升了8倍。</p><p>SIMD 实现的原理是 CPU 在设计的时候，增加了一些专用的向量（vector）寄存器，这些寄存器的大小往往大于普通寄存器。比如：SSE 的 XMM寄存器长度为 128位，AVX 和 AVX2 的 YMM寄存器为 256位。因此，这些专用的向量寄存器可以同时放入多个数据，但需要注意，<strong>每个向量寄存器中放入的多个数据，需要保证数据类型是一致的</strong>。</p><p>Linus（Linux创始人）有一句名言 “Talk is cheap, show me the code”（废话少说，放码过来）。SIMD 的基本概念最好通过一个简单的源代码示例来说明，下面使用 C++ 和 SIMD 分别实现了两个函数，这两个函数对一个单精度浮点数数组执行相同的运算。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;immintrin.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// C++实现，对于长度为n的浮点数组x和y，计算其中每个元素的和，保存到数组z中。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CalcZ_Cpp</span><span class="params">(<span class="type">float</span>* z, <span class="type">const</span> <span class="type">float</span>* x, <span class="type">const</span> <span class="type">float</span>* y, <span class="type">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        z[i] = x[i] + y[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SIMD 实现</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CalcZ_Iavx</span><span class="params">(<span class="type">float</span>* z, <span class="type">const</span> <span class="type">float</span>* x, <span class="type">const</span> <span class="type">float</span>* y, <span class="type">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">size_t</span> i = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 每次循环中，计算数组中的8个元素。</span></span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> num_simd_elements = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (; n - i &gt;= num_simd_elements; i += num_simd_elements)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 使用 C++ SIMD 内联函数 _mm256_loadu_ps()</span></span><br><span class="line">        <span class="comment">// 从数组x中加载连续的8个浮点数，放到 __m256 类型的变量 x_vals 中</span></span><br><span class="line">        <span class="comment">// __m256是一个通用容器，可以存放8个float类型的数值。</span></span><br><span class="line">        __m256 x_vals = _mm256_loadu_ps(&amp;x[i]);</span><br><span class="line">        __m256 y_vals = _mm256_loadu_ps(&amp;y[i]);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用 C++ SIMD 内联函数 _mm256_add_ps()</span></span><br><span class="line">        <span class="comment">// 同时对 x_vals 和 y_vals 中的8个浮点数分别计算加法</span></span><br><span class="line">        <span class="comment">// 将对应元素的和存放到__m256 类型的变量 z_vals</span></span><br><span class="line">        __m256 z_vals = _mm256_add_ps(x_vals, y_vals);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 C++ SIMD 内联函数 _mm256_storeu_ps()</span></span><br><span class="line">        <span class="comment">// 将 z_vals 中的8个元素，保存到浮点数组z中。</span></span><br><span class="line">        _mm256_storeu_ps(&amp;z[i], z_vals);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当数组中剩余元素的个数少于8个时，使用普通 C++ 计算。</span></span><br><span class="line">    <span class="keyword">for</span> (; i &lt; n; i += <span class="number">1</span>)</span><br><span class="line">        z[i] = x[i] + y[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>C++编译器在调用 C++ SIMD 内联函数时，与调用普通 C++函数不同。在上述示例中，<strong>C++编译器直接将每个 C++ SIMD 内联函数翻译成对应的 AVX 汇编语言指令，没有普通 C++函数调用的开销</strong>。</p><h1>Intel SIMD 指令集</h1><p>上文中提到，SIMD是一种并行计算架构。各 CPU 生产厂商都将这种架构集成到了自己的产品中。本文及后文中的 SIMD 教程，都以 Intel 的 x86 系列为代表，介绍 SIMD 的相关知识。</p><h2 id="MMX">MMX</h2><p><a href="https://en.wikipedia.org/wiki/MMX_(instruction_set)">MMX</a> 是 Intel 在1997年推出的第一个 x86 SIMD 指令集扩展，此扩展使用 64位大小的寄存器，实现了简单了 SIMD 操作。</p><p>MMX 扩展没有向 x86平台添加任何新的寄存器，只是将原本的浮点寄存器重新用于 SIMD 整数运算和其他操作。</p><h2 id="SSE">SSE</h2><p>1999年，Intel 推出了新的 SIMD 技术，称为 <a href="https://en.wikipedia.org/wiki/Streaming_SIMD_Extensions">Streaming SIMD extensions（SSE)</a>)。SSE 增加了 128位大小的专用寄存器，支持单精度浮点数的 SIMD计算。</p><p>2000年，Intel 又推出了 SSE2，在 SSE 的基础上增加了双精度浮点数的 SIMD 计算，还支持了整数的 SIMD 计算。</p><p>SSE2 之后，又相继推出了 SSE3(2004年)、SSE3(2006年)、SSE4.1(2008年) 和 SSE4.2(2008年)。这些扩展包含了额外的 SIMD指令，使得数据操作更为方便，但没有增加新的寄存器。</p><h2 id="AVX">AVX</h2><p>2011年，Intel 推出了 <a href="https://en.wikipedia.org/wiki/Advanced_Vector_Extensions">Advanced Vector Extensions（AVX)</a>)。AVX 使用 256位宽的寄存器，支持了单精度和双精度浮点数的 SIMD运算。</p><p>2013年，Intel 推出了 AVX2，在 AVX的基础上，支持了整数的 SIMD运算。还增加了一些内联函数（如broadcast, gather, 和 permute），增强了数据传输功能。</p><p>2017年，Intel 推出了 AVX-512，此架构支持使用 512位宽的寄存器，对浮点数和整数进行 SIMD运算。不过的目前为止（2023年3月），AVX-512 对于消费级 CPU 的支持并不好，比如 12 代酷睿就不支持 AVX-512，因此为了保证代码的兼容性，还是尽量不使用 AVX-512。</p><h2 id="Intel-内联函数指南网站">Intel 内联函数指南网站</h2><p><a href="https://software.intel.com/sites/landingpage/IntrinsicsGuide">Intel Intrinsics Guide website</a> 是 Intel 公司提供的 x86 相关的 SIMD编程文档。该网站记录了 Intel C++ 编译器支持的 C++ SIMD 内联函数。这些函数中的大多数也可以用在使用 Visual C++或 GUN C++开发的程序中。</p><p>该网站十分重要，是获取 x86 C++ SIMD 内联函数信息的不可或缺的在线参考。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SIMD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一篇博客</title>
      <link href="/posts/e838/"/>
      <url>/posts/e838/</url>
      
        <content type="html"><![CDATA[<h1>第一篇博客</h1><p>大家好！</p><p>我是孙鹏宇。</p><p>欢迎大家来到我的个人博客网站！</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
